# Lab 2: Memory Management
在这个实验中需要给操作系统写内存管理的代码。内存管理主要有两部分。  
第一部分是内核的物理内存申请和释放，操作的最小单位是一个物理页（4KB）。  
第二部分是虚拟内存，虚拟地址的映射以及用户程序的物理寻址。

将代码切换到lab2分支
```bash
git checkout -b lab2 origin/lab2
git merge lab1  
```
合并lab1的代码到lab2,如果出现冲突需要先解决冲突在合并。lab2新增的代码
- `inc/memlayout.h`
- `kern/pmap.c`
- `kern/pmap.h`
- `kern/kclock.h`
- `kern/kclock.c`



## Part1: Physical Page Management
操作系统必须实时跟踪哪一部分的物理RAM是空闲的和可用的。JOS是以页的粒度管理内存，所以它可以使用MMU映射和保护每一块分配的内存。  
写一个物理页分配器。在实现虚拟内存之前需要完成物理页的分配器，因为页表管理的代码需要分配物理内存存在页表中。

#### Exercise1:
> 实现 `kern/pmap.c` 中下面的函数：
>- `boot_alloc()` //  分配n bytes大小的空间，空间大小以PAGE大小向上取整。
>- `mem_init()`  (only up to the call to `check_page_free_list(1)`)
>- `page_init()` // 将可使用的内存以链表的形式连接在一起。
>- `page_alloc()`  // 分配一个空闲page
>- `page_free()`   // 与上面的功能相反，收回一个空闲页。  
>
>`check_page_free_list()` 和 `check_page_alloc()` 用于测试物理页分配器。启动JOS观察 `check_page_alloc()` 是否成功。可以添加自己的 `assert()` 验证假设是否成功。

`boot_alloc(uint32_t n)` 这个函数是在系统建立虚拟内存映射的时候使用，后面所有的内存分配单位都是页（PAGA），并且使用`page_alloc` ， `boot_alloc()` 的函数完整代码：
```c++
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	// end 是链接脚本中的一个变量，表示的是内核最后的内存的地址（虚拟地址）
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);  // 获取内核存放地址下一个4KB（PGSIZE）对齐的内存地址
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	result = nextfree;
	if ((uint32_t)nextfree-KERNBASE > (npages*PGSIZE)) {
		panic("OUT OF MEMORY");
	}
	nextfree = ROUNDUP(nextfree + n, PGSIZE);  // 更新下一个空闲页的地址

	return result;
}
```
在 `mem_init()`补充代码, 分配用于存放页表的物理空间：
```c++
//////////////////////////////////////////////////////////////////////
// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
// The kernel uses this array to keep track of physical pages: for
// each physical page, there is a corresponding struct PageInfo in this
// array.  'npages' is the number of physical pages in memory.  Use memset
// to initialize all fields of each struct PageInfo to 0.
// Your code goes here:
// 分配用于存放页表信息的物理空间
pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
memset(pages, 0, npages * sizeof(struct PageInfo));  // 清空分配的空间
```

物理内存总共有 131072KB（128MB），因此需要 131072/4 = 32768 个 `PageInfo` 管理，每一 `PageInfo` 都会管理一个物理页。


物理内存分布：

![](./images/lab2-e1-1.drawio.png)

JOS 将内存分成了四个部分：
1. [0-4KB): IDT表， BIOS （不可用）
2. [4-640)KB： base memory （不可用）
3. [640-1024)： IO hole （不可用）
4. [1024, ...) （可用， 但是前面一部分被内核占用了）

物理内存的获取是通过IO指令读取CMOS的数，相关参考资料
- [CMOS参考资料](https://wiki.osdev.org/CMOS),
- [CMOS 芯片](https://web.stanford.edu/class/cs140/projects/pintos/specs/mc146818a.pdf)
- [Detecting_Memory_(x86)](https://wiki.osdev.org/Detecting_Memory_(x86))

---

`page_init()` 函数主要是将物理悲内存中空闲的部分以链表的形式存储起来，也就是初始化 `pages` 数组，将所有的内存都记录下来， `page_init()` 函数的完整代码：

```c++
//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//     页0， 存放IDT
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free. 
	//	   基址（640KB)剩下的内存
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated. 
	// 	   IO hole 的内存不能使用
	//  4) Then extended memory [EXTPHYSMEM, ...).  所有剩下的物理内存
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//     所有剩下的物理内存，这些并不都是空闲内存，部分内页是有数据的，比如内核。
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;

	// page_in_use_end 没有使用的内存地址的开始位置（页），即使用了的结束位置
	// npages_basemem = 640K / 4k , 640KB 的基址的物理页
	// (1MB - 640KB)/4KB = 96  ， IO hole的物理页
	// ((uint32_t)boot_alloc(0) - KERNBASE) /PGSIZE  内核使用的物理页, 
	const size_t page_in_use_end = 
			npages_basemem + 96 + ((uint32_t)boot_alloc(0) - KERNBASE) / PGSIZE;

	// page_in_use_end = 600， 已经使用了物理页
	cprintf("now in used: %d\n", page_in_use_end);

	// 设置page0为使用
	cprintf("%08x %08x\n", pages, (uint32_t)boot_alloc(0));

	// 1. 0-4KB, page0 存放IDT，
	pages[0].pp_ref = 1;

	// 2. 4-640KB
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	// 3. 640 - used,  I/O hole 和 内核代码
	for(i = npages_basemem; i < page_in_use_end; ++i) {
		pages[i].pp_ref = 1;
	}

	// 4. kernel_end~... ，内核代码后面的都是空闲内存
	for (i = page_in_use_end; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
```
物理内存的初始化，空闲物理内存被存放在一个链表中，`page_free_list` 是链表的头。注意，这个链表的方向和pages数组的方向是相反的，比如pages[1...n] 是空闲的物理内存，链表的结构是 `pages[n]->pages[n-1]->...->pages[0]->NULL`。 所以空闲物理内存的链表的头节点指向的是空闲物理内存数组最后一个空闲的物理页，pages 数组元素 pp_link的指向也是反向的。
 
<!-- TODO  将page_free_list的顺序改成和pages数组的顺序一致 -->
---

`struct PageInfo* page_alloc(int alloc_flags)` 分配物理内存

```c++
//
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	struct PageInfo* temp;
	if (page_free_list == NULL) {  // 没有空闲的物理内存
		return NULL;
	}
	// 空闲内存页的链表操作，删除头节点
	// page_free_list 指向新的头节点
	temp = page_free_list;
	page_free_list = temp->pp_link;
	temp->pp_link = NULL;
	if (alloc_flags & ALLOC_ZERO) {
		//因为所有的程序中的地址都是虚拟地址进行操作的，所以我们需要将真实的物理页面转换到虚拟地址下初始化
		memset(page2kva(temp), 0, PGSIZE);
	}
	return temp;
}
```


---

`void page_free(struct PageInfo *pp)` 把需要释放的内存添加到空闲链表的头，注意一些先决条件：
```c++
//
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	// 当前还存在引用的或是 pp_link 不是NULL的内存允许释放
	if (pp->pp_ref != 0 || pp->pp_link != NULL) {
		panic("can't properly free page\n");
	}
	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```



